var documenterSearchIndex = {"docs":
[{"location":"fglm/","page":"FGLM Algorithms","title":"FGLM Algorithms","text":"Pages = [\"fglm.md\"]","category":"page"},{"location":"fglm/#FGLM-Algorithms","page":"FGLM Algorithms","title":"FGLM Algorithms","text":"","category":"section"},{"location":"fglm/","page":"FGLM Algorithms","title":"FGLM Algorithms","text":"Let K be a field, and let I subset K x_1 dots x_n be a zero-dimensional ideal. Givean a _1-Gröbner basis G subset I be a  of I, with variants of the FGLM algorithm one can perform term order conversion from G to a _2-Gröbner basis. This module implements the following variants of FGLM:","category":"page"},{"location":"fglm/","page":"FGLM Algorithms","title":"FGLM Algorithms","text":"The original FGLM algorithm https://doi.org/10.1006/jsco.1993.1051.\nFGLM with fast matrix multiplication https://doi.org/10.1145/2608628.2608669.\nSparse FGLM https://doi.org/10.1016/j.jsc.2016.07.025.","category":"page"},{"location":"fglm/","page":"FGLM Algorithms","title":"FGLM Algorithms","text":"Currently, only the following FGLM algorithm functionality is implemented:","category":"page"},{"location":"fglm/","page":"FGLM Algorithms","title":"FGLM Algorithms","text":"Only term order conversion to a lexicographic order is supported.\nOnly the probabilistic versions of the fast matrix multiplication and sparse FGLM are implemented.\nFast matrix multiplication and sparse FGLM are only supported over finite fields.\nFGLM algorithms are only supported for ideals in x_n-shape position, i.e. the lexicographic Gröbner basis has the shape","category":"page"},{"location":"fglm/","page":"FGLM Algorithms","title":"FGLM Algorithms","text":"beginaligned\n    g_1 = x_1 - f_1 (x_n) \n    vdots \n    g_n - 1 = x_n - 1 f_n - 1 (x_n) \n    g_n = f_n (x_n)\nendaligned","category":"page"},{"location":"fglm/#Functionality","page":"FGLM Algorithms","title":"Functionality","text":"","category":"section"},{"location":"fglm/#Standard-FGLM","page":"FGLM Algorithms","title":"Standard FGLM","text":"","category":"section"},{"location":"fglm/#FglmAlgorithms.fglm_lex_shape_position-Tuple{MPolyIdeal}","page":"FGLM Algorithms","title":"FglmAlgorithms.fglm_lex_shape_position","text":"fglm_lex_shape_position(\n    I::MPolyIdeal\n)\n\nComputes the lexicographic Gröbner basis of an ideal I subset K x_1 dots x_n via the standard FGLM algorithm. If the lexicographic Gröbner basis of I is not in x_n-shape position an error is returned.\n\nArguments\n\nI::MPolyIdeal: zero-dimensional ideal for which one wants to compute the lexicographic Gröbner basis.\n\nExamples\n\njulia> P, (x, y) = polynomial_ring(GF(101), [\"x\", \"y\"], internal_ordering=:degrevlex);\n\njulia> I = ideal([y^2 + x - 1 + x, x^2 - y + 1]);\n\njulia> fglm_lex_shape_position(I)\nGröbner basis with elements\n  1: y^4 + 99*y^2 + 97*y + 5\n  2: x + 51*y^2 + 50\nwith respect to the ordering\n  lex([x, y])\n\n\n\n\n\n","category":"method"},{"location":"fglm/#FglmAlgorithms.fglm_lex_shape_position-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T<:MPolyRingElem","page":"FGLM Algorithms","title":"FglmAlgorithms.fglm_lex_shape_position","text":"fglm_lex_shape_position(\n    G::Vector{T},\n    B::Vector{T}\n) where T <: MPolyRingElem\n\nComputes the lexicographic Gröbner basis of ideal (G) subset K x_1 dots x_n via the standard FGLM algorithm. If the lexicographic Gröbner basis of (G) is not in x_n-shape position an error is returned.\n\nArguments\n\nG::Vector{MPolyRingElem}: zero-dimensional Gröbner basis for which one wants to compute the lexicographic Gröbner basis.\nB::Vector{MPolyRingElem}: vector space basis of the quotient ring.\n\nExamples\n\njulia> P, (x, y) = polynomial_ring(GF(101), [\"x\", \"y\"], internal_ordering=:degrevlex);\n\njulia> G = [y^2 + x - 1 + x, x^2 - y + 1];\n\njulia> B = [P(1), x,  y, x * y];\n\njulia> fglm_lex_shape_position(G, B)\nGröbner basis with elements\n  1: y^4 + 99*y^2 + 97*y + 5\n  2: x + 51*y^2 + 50\nwith respect to the ordering\n  lex([x, y])\n\n\n\n\n\n","category":"method"},{"location":"fglm/#FGLM-With-Fast-Matrix-Multiplication","page":"FGLM Algorithms","title":"FGLM With Fast Matrix Multiplication","text":"","category":"section"},{"location":"fglm/#FglmAlgorithms.fglm_matrix_lex_shape_position-Tuple{MPolyIdeal}","page":"FGLM Algorithms","title":"FglmAlgorithms.fglm_matrix_lex_shape_position","text":"fglm_matrix_lex_shape_position(\n    I::MPolyIdeal\n)\n\nComputes the lexicographic Gröbner basis of an ideal I subset K x_1 dots x_n via the fast matrix multiplication FGLM algorithm. If the lexicographic Gröbner basis of I is not in shape position with respect to the last variable an error is returned.\n\nArguments\n\nI::MPolyIdeal: zero-dimensional ideal for which one wants to compute the lexicographic Gröbner basis.\n\nExamples\n\njulia> P, (x, y) = polynomial_ring(GF(101), [\"x\", \"y\"], internal_ordering=:degrevlex);\n\njulia> I = ideal([y^2 + x - 1 + x, x^2 - y + 1]);\n\njulia> fglm_matrix_lex_shape_position(I)\nGröbner basis with elements\n  1: x + 51*y^2 + 50\n  2: y^4 + 99*y^3 + 97*y^2 + 5\nwith respect to the ordering\n  lex([x, y])\n\n\n\n\n\n","category":"method"},{"location":"fglm/#FglmAlgorithms.fglm_matrix_lex_shape_position-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T<:MPolyRingElem","page":"FGLM Algorithms","title":"FglmAlgorithms.fglm_matrix_lex_shape_position","text":"fglm_matrix_lex_shape_position(\n    G::Vector{T},\n    B::Vector{T}\n) where T <: MPolyRingElem\n\nComputes the lexicographic Gröbner basis of an ideal (G) subset K x_1 dots x_n via the fast matrix multiplication FGLM algorithm. If the lexicographic Gröbner basis of (G) is not in shape position with respect to the last variable an error is returned.\n\nArguments\n\nG::Vector{MPolyRingElem}: zero-dimensional Gröbner basis for which one wants to compute the lexicographic Gröbner basis.\nB::Vector{MPolyRingElem}: vector space basis of the quotient ring.\n\nExamples\n\njulia> P, (x, y) = polynomial_ring(GF(101), [\"x\", \"y\"], internal_ordering=:degrevlex);\n\njulia> G = [y^2 + x - 1 + x, x^2 - y + 1];\n\njulia> B = [P(1), x,  y, x * y];\n\njulia> fglm_sparse_lex_shape_position(G, B)\nGröbner basis with elements\n  1: x + 51*y^2 + 50\n  2: y^4 + 99*y^3 + 97*y^2 + 5\nwith respect to the ordering\n  lex([x, y])\n\n\n\n\n\n","category":"method"},{"location":"fglm/#Sparse-FGLM","page":"FGLM Algorithms","title":"Sparse FGLM","text":"","category":"section"},{"location":"fglm/#FglmAlgorithms.fglm_sparse_lex_shape_position-Tuple{MPolyIdeal}","page":"FGLM Algorithms","title":"FglmAlgorithms.fglm_sparse_lex_shape_position","text":"fglm_sparse_lex_shape_position(\n    I::MPolyIdeal\n)\n\nComputes the lexicographic Gröbner basis of an ideal I subset K x_1 dots x_n via the sparse FGLM algorithm. If the lexicographic Gröbner basis of I is not in x_n-shape position an error is returned.\n\nArguments\n\nI::MPolyIdeal: zero-dimensional ideal for which one wants to compute the lexicographic Gröbner basis.\n\nExamples\n\njulia> P, (x, y) = polynomial_ring(GF(101), [\"x\", \"y\"], internal_ordering=:degrevlex);\n\njulia> I = ideal([y^2 + x - 1 + x, x^2 - y + 1]);\n\njulia> fglm_sparse_lex_shape_position(I)\nGröbner basis with elements\n  1: x + 51*y^2 + 50\n  2: y^4 + 99*y^3 + 97*y^2 + 5\nwith respect to the ordering\n  lex([x, y])\n\n\n\n\n\n","category":"method"},{"location":"fglm/#FglmAlgorithms.fglm_sparse_lex_shape_position-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T<:MPolyRingElem","page":"FGLM Algorithms","title":"FglmAlgorithms.fglm_sparse_lex_shape_position","text":"fglm_lex_shape_fglm_sparse_lex_shape_positionposition(\n    G::Vector{T},\n    B::Vector{T}\n) where T <: MPolyRingElem\n\nComputes the lexicographic Gröbner basis of ideal (G) subset K x_1 dots x_n via the sparse FGLM algorithm. If the lexicographic Gröbner basis of (G) is not in x_n-shape position an error is returned.\n\nArguments\n\nG::Vector{MPolyRingElem}: zero-dimensional Gröbner basis for which one wants to compute the lexicographic Gröbner basis.\nB::Vector{MPolyRingElem}: vector space basis of the quotient ring.\n\nExamples\n\njulia> P, (x, y) = polynomial_ring(GF(101), [\"x\", \"y\"], internal_ordering=:degrevlex);\n\njulia> G = [y^2 + x - 1 + x, x^2 - y + 1];\n\njulia> B = [P(1), x,  y, x * y];\n\njulia> fglm_sparse_lex_shape_position(G, B)\nGröbner basis with elements\n  1: x + 51*y^2 + 50\n  2: y^4 + 99*y^3 + 97*y^2 + 5\nwith respect to the ordering\n  lex([x, y])\n\n\n\n\n\n","category":"method"},{"location":"multiplication-matrix/","page":"Multiplication Matrix","title":"Multiplication Matrix","text":"Pages = [\"multiplication-matrix.md\"]","category":"page"},{"location":"multiplication-matrix/#Multiplication-Matrix","page":"Multiplication Matrix","title":"Multiplication Matrix","text":"","category":"section"},{"location":"multiplication-matrix/","page":"Multiplication Matrix","title":"Multiplication Matrix","text":"Let K be a field, let I subset K x_1 dots x_n be a zero-dimensional ideal, and let G subset I be a -Gröbner basis of I. Then A = K x_1 dots x_n  I is a finite dimensional K-vector space, and a vector space basis is given by all monomials B not contained in the ideal of -leading terms of I. In particular, for f in K x_1 dots x_n the map x mapsto x cdot f is K-linear on A. So, it can be represented by a matrix mathbfM_f in K^B times B. The following functions provide functionality for the computation of mathbfM_f, given as input","category":"page"},{"location":"multiplication-matrix/","page":"Multiplication Matrix","title":"Multiplication Matrix","text":"a polynomial f,\na zero-dimensional -Gröbner basis G, and\nthe K-vector space basis B of K x_1 dots x_n  (G) induced by G.","category":"page"},{"location":"multiplication-matrix/","page":"Multiplication Matrix","title":"Multiplication Matrix","text":"For maximum performance, no boundary checks are performed.","category":"page"},{"location":"multiplication-matrix/#Functionality","page":"Multiplication Matrix","title":"Functionality","text":"","category":"section"},{"location":"multiplication-matrix/#FglmAlgorithms.normal_form_to_sparse_row-Union{Tuple{T}, Tuple{T, Vector{T}}} where T<:MPolyRingElem","page":"Multiplication Matrix","title":"FglmAlgorithms.normal_form_to_sparse_row","text":"normal_form_to_sparse_row(\n    f::T,\n    B::Vector{T}\n) where T <: MPolyRingElem\n\nComputes the sparse coefficient vector of an element f in a zero-dimensional quotient ring Kx_1  x_n  I with respect the K-vector space basis B. Assumes that f is already in normal form. For internal use only.\n\nArguments\n\nf::MPolyRingElem: a multivariate polynomial in normal form.\nB::Vector{MPolyRingElem}: a vector space basis of Kx_1  x_n  I.\n\n\n\n\n\n","category":"method"},{"location":"multiplication-matrix/#FglmAlgorithms.multiplication_matrix_dense-Union{Tuple{T}, Tuple{T, Vector{T}, Vector{T}}} where T<:MPolyRingElem","page":"Multiplication Matrix","title":"FglmAlgorithms.multiplication_matrix_dense","text":"multiplication_matrix_dense(\n    f::T,\n    G::Vector{T},\n    B::Vector{T}\n) where T <: MPolyRingElem\n\nFor a polynomial f, computes the multiplication matrix of x mapsto x cdot f over K x_1  x_n  (G) with respect to the K-vector space basis B. The multiplication matrix is represented as dense matrix. For internal use only\n\nArguments\n\nf::MPolyRingElem: a multivariate polynomial.\nG::Vector{MPolyRingElem}: a zero-dimensional Gröbner basis with respect to the default ordering of the polynomial ring.\nB::Vector{MPolyRingElem}: vector space basis of K x_1  x_n  (G) with respect to the Gröbner basis G.\n\n\n\n\n\n","category":"method"},{"location":"multiplication-matrix/#FglmAlgorithms.multiplication_matrix-Union{Tuple{T}, Tuple{T, Vector{T}, Vector{T}}} where T<:MPolyRingElem","page":"Multiplication Matrix","title":"FglmAlgorithms.multiplication_matrix","text":"multiplication_matrix(\n    f::T,\n    G::Vector{T},\n    B::Vector{T};\n    sparse::Bool=true\n) where T <: MPolyRingElem\n\nFor a polynomial f, computes the multiplication matrix of x mapsto x cdot f over K x_1  x_n  (G) with respect to the K-vector space basis B. For internal use only.\n\nArguments\n\nf::MPolyRingElem: a multivariate polynomial.\nG::Vector{MPolyRingElem}: a zero-dimensional Gröbner basis with respect to the default ordering of the polynomial ring.\nB::Vector{MPolyRingElem}: vector space basis of K x_1  x_n  (G) with respect to the Gröbner basis G.\nsparse::Bool: optional parameter to reprsent the multiplication matrix as sparse matrix. Default valuse is true.\n\n\n\n\n\n","category":"method"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Pages = [\"utilities.md\"]","category":"page"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Collection of functions which are shared by the FGLM algorithms.","category":"page"},{"location":"utilities/#Functionality","page":"Utilities","title":"Functionality","text":"","category":"section"},{"location":"utilities/#FglmAlgorithms.is_zero_dimensional_gb-Union{Tuple{Vector{T}}, Tuple{T}} where T<:MPolyRingElem","page":"Utilities","title":"FglmAlgorithms.is_zero_dimensional_gb","text":"is_zero_dimensional_gb(\n    G::Vector{T}\n) where T <: MPolyRingElem\n\nA fast check whether a polynomial vector is a zero-dimensional Gröbner basis with respect to the default ordering of the polynomial ring. For internal use only.\n\nArguments\n\nG::Vector{T}: an asserted zero-dimensional Gröbner basis.\n\n\n\n\n\n","category":"method"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FglmAlgorithms.jl implements term order conversion algorithms for zero-dimensional ideals to a lexicographic Gröbner basis on top of the OSCAR computer algebra system.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package requires Julia 1.11 or higher and OSCAR 1.0 or higher.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For installation, simply type","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"FglmAlgorithms\")","category":"page"},{"location":"#A-Simple-Example","page":"Home","title":"A Simple Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After installation you can use the package in combination with OSCAR. We provide a simple example","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Oscar, FglmAlgorithms\n\nP, (x, y) = polynomial_ring(GF(101), [\"x\", \"y\"], internal_ordering=:degrevlex)\nI = ideal([y^2 - x + 1, x^2 + x - y - 1])\n\ngb_lex_1 = fglm_lex_shape_position(I)\ngb_lex_2 = fglm_matrix_lex_shape_position(I)\ngb_lex_3 = fglm_sparse_lex_shape_position(I)","category":"page"},{"location":"berlekamp-massey/","page":"Berlekamp-Massey Algorithm","title":"Berlekamp-Massey Algorithm","text":"Pages = [\"berlekamp-massey.md\"]","category":"page"},{"location":"berlekamp-massey/#Berlekamp-Massey-Algorithm","page":"Berlekamp-Massey Algorithm","title":"Berlekamp-Massey Algorithm","text":"","category":"section"},{"location":"berlekamp-massey/","page":"Berlekamp-Massey Algorithm","title":"Berlekamp-Massey Algorithm","text":"The algorithm is used to compute the univariate polynomial in the fast matrix multiplication and sparse FGLM algorithms.","category":"page"},{"location":"berlekamp-massey/#Functionality","page":"Berlekamp-Massey Algorithm","title":"Functionality","text":"","category":"section"},{"location":"berlekamp-massey/#FglmAlgorithms.berlekamp_massey-Union{Tuple{T}, Tuple{S}, Tuple{Vector{S}, T}} where {S<:RingElement, T<:MPolyRingElem}","page":"Berlekamp-Massey Algorithm","title":"FglmAlgorithms.berlekamp_massey","text":"berlekamp_massey(\n    a::Vector{S},\n    x::T\n) where {S <: RingElement, T <: MPolyRingElem}\n\nComputes the minimal polynomial of a linear recurrent sequence. For internal use only.\n\nArguments\n\na::Vector{S}: a sequence of ring (in practice only field) elements.\nx::T: variable in which the polynomial is computed.\n\n\n\n\n\n","category":"method"}]
}
